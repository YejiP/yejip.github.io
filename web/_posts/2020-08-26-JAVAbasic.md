# JAVA 용어 정리와 기본 개념

```
혼자 야매로 하다가 처음부터 배울 기회가 생겨서 좋다.
```



## 용어정리

**Modifier (접근지정자)** : public, protected, dafault ,private 

**Identifier (식별자)** : 클래스 , 변수, 메소드 등을 식별하기 위해 사용하는 이름

​	*식별자 규칙*

```
1. 첫 문자는 숫자가 아니다. 
2. _ 와 $ 로 처음 시작 가능하다. 
3. 영문자나 숫자로만 만든다. (협업 시)
4. 클래스의 이름은 대문자로, 변수나 메소드의 이름은 소문자로 만든다. 
5. 두번째 단어는 대문자로 ex) inputnumber --> inputNumber
```



**Reserved word (예약어)** : 자바에는 대략 50여개, case, void, for , while 등등 같은게 있다.



## 자료형

**기본 자료형** 

1. 정수 : 

   ```
   byte(1 바이트: -128~127)
   short(2 바이트: -2^16 ~2^16)
   int(4 바이트 : -2^32 ~ 2^31)
   long(8 바이트 : -2^64 ~ 2*64 - 1)
   
   연산할 때 int 사용한다. byte와 short는 보통 저장할 때 사용한다.
   ```

   

2. 실수 : 

   ```
   float(4 : 3.4E-38(-3.4*10^38) ~ 3.4E+38(3.4*10^38) )
   double(8 : 1.79E-308(-1.79*10^308) ~ 1.79E+308(1.79*10^308)) 
   
   주의) float형으로 쓰고싶으면, 3.14f 라고 해야한다. 3.14F, 0.5E-3(10의 -3승)
   ```

   

   

3. 문자 : char(2) 'a' 항상, 작은 쿼테이션 안에. '%' '강'

4. 논리 : boolean(1) true, false



**참조 자료형**

1) 변수 선언 :  JVM에게 알려준다. : int age; --> 이런 식으로 변수 선언.

2) 대입 =  : 오른 쪽에 있는 값을 왼쪽의 변수에 넣어라.

int radius = 5; 선언과 동시에 초기화

```
//정수변수
byte by = 10; //값 
short sh = 27;
int i = 256;
long l = 25600L;
LV = RV(변수, 값, 수식) = LV가 RV보다 크거나(변수형이니까, 롱 = 인트 이런식으로) 같아야한다.

byte와 short는 연산하기 위한 용이지, 계산은 int로 한다. 

//실수변수
float fl = 3.14; --> 3.14는 더블인데 더블은 플롯보다 크다. 
float fl = 3.14f; 일케하면 된다. 

//문자변수
char grade - '%';
'홍길동' -> 이거는 문자가 아니라 문자열이다. 
문자열은 "" 큰 따옴표 써야한다. 
String name = "홍길동"

```


​	

8진수 : 정수 앞 0

16진수 : 정수 앞 0x

2진수 : 정수 앞 0b



유니코드: 

​	문자마다 고유한 코드 값을 부여하여 모든 문자를 16비트로 표현



MSB: Most Significant bit (맨 앞 비트, 부호 결정)

LSB : Least Significant bit (맨 끝 비트, 짝홀 결정)



**타입을 보고 연산**

````
total = 229;
double avg = total /3; 
연산자 : 나누기, 대입 --> 우선순위 때문에 소숫점 버린다. 
값을 보고 연산하는게 아니라, 타입을 보고 연산을 한다.

ex) 
정수타입/ 정수타입 = 정수
일케된다. 

344/3 이라고 하면, double에 저장하면 double로 나오는데,
int a, int b를 각각 344 와 3으로 하고
double = a/b 이런식으로 할 떄, 타입을 보고

오 정수 나누기 정수네? 그럼 정수겠다! 하고 정수로 표현해주고, 
더블에다가 .0으로 저장해준다. 

아래와 같이 해주면 된다.
정수/실수 ==> 실수 ( 큰 타입으로 맞춘다.)

	double avg = total/3;
	double avg2 = total/3.0;
	System.out.println(avg);
	System.out.println(avg2);
		
		
	87.0
	87.66666666666667
````



## 연산자

1. **단항연산자**

   ```
   + - ++ -- ~ ! (type) .(클래스.메소드)
   
   int a = 10;
   a = -a;
   (int)b = 10.4;
   ```

   

2. **이항 연산자**

   ```
   산술 연산자 : + - * / %(나머지)
   비교 연산자 : > < >= <= == !=
   논리 연산자 : &&(논리곱, 범위 연산 시) ||(논리합) 
   대입 연산자 : =
   ```



3. **삼항 연산자**

```
항1 ? 항2 : 항3

항1) 조건
(a >b)
항2) 참일 때의 값

항3) 거짓일 때의 값

ex)
String data = (age >= 14 && age <= 19) ? "청소년 입니다." : "청소년이 아닙니다." 
```



4. 비트 연산자

```
& : 비트 단위의 AND
| : 비트 단위의 OR
^ : 비트 단위의 XOR
~ : 비트 단위의 NOT

>> shift: 첫 비트 부호 값으로 채움
>>> shift: 첫 비트 0으로 채움
<< shift : 첫 비트 0으로 채움

ex)선언
byte a = 10 l --> a : 0000 0101 

a : 1001 0011 =(a >> 1)=> 1100 1001 (2의 1승 나눔)
b : 0000 1000 =(b << 2)=> 0010 0000 (2의 2승 곱함)
```



4. 

a++와 ++a는 우선순위가 다르다.

```
int a,b =0;
b = a++;
--> b=a 먼저 한다.
그 후 sysout 하면 b는 0, a는 1 이 나온다. 

int a,b =0;
b = ++a;
--> 이런 경우에는 ++a가 =보다 우선순위가 더 높아서 b= a+1, a는1, b는1이 나온다.


b = ++a + a++;

b = ++a + ++a;

상수 앞에는 못쓴다. ++1; 1++; (1=1+1 이런 의미라서) --> 틀림
```



## 입력

Scanner (하나의 타입)

```
import java.util.Scanner;

//스캐너 객체 생성
Scanner keyin = new Scanner(System.in);
//System.in 은 키보드 의미. System.out은 모니터 의미

int a = keyin.nextInt(); //키보드로부터 데이터를 입력받는다.int 데이터
```



화이트 스페이스 : 탭 엔터 스페이스 필요하다.



## 형변환

데이터 타입을 변환 시켜주는 것. 프로모션이라고 한다. 

LV = RV (LV의 타입이 RV의 타입보다 크거나 같아야 한다.)



byte --> short ----

​							-----> int  ----> long ---> float ---> double

​				char ----

short에서 char로, byte 에서 char 로 프로모션은 불가능하다. 

캐릭터에는 음수가 없기 때문에 표현할 수 업나보다. 



long과 float 중 long은 8바이트를 사용하고, float은 4 바이트다. 그렇지만 float이 나타낼 수 있는 숫자가 더 크기 때문에 long --> float 으로 간다. 





System.exit(0) -->  프로그램 종료



for (int i=0;i<10;i++){

if(i==5) continue; //continue 아래 문장은 다 생략한다.!

System.out.println(i);

}





Escape Sequecne

'\t'

'\n' : 새로운 줄 아래로.

'\r' : 맨 앞으로

'\r\n' :자바에서의 엔터 (아래로, 맨 앞으로)



## 배열

배열을 생성하여 배열의 크기가 결정하면 해당 배열의 크기값을 갖는 LENGTH 속성(read only)이 생성됨.

배열을 참조하는 변수는 STACK영역에, 배열은 HEAP 영역에 생성되기 때문에 

heap 영역에 생성되는 변수는 자동으로 0으로 초기화된다.



## 메모리 공간

**JAVA의 메모리 공간 : HEAP **

NEW에 의해서 생성되는 것

garbage collector 에 의해 관리 되고, 동적인 공간

메모리에 이름이 없다. stack에 있는 참조 변수가 heap의 주소값을 연결시켜서 찾아가는 구조.

스택 영역을 통해서만 갈 수 있다.



**JAVA의 메모리 공간 STACK**

지역 변수들 주로 들어간다. (ex. int a)

정적인 공간, 선언에 의해서 사용된다.

메모리에 이름이 있다.





